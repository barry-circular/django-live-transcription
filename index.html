<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Appointment Asistant</title>
    <link rel="stylesheet" href="/static/deepgram-styles.css">
</head>
<body>
    <div class="dg-card dg-constrain-width dg-spacing-mobile-compact">
        <h1 class="dg-hero-title">Appointment Assistant</h1>

        <div class="dg-action-group">
            <button id="startBtn" class="btn btn--primary">Start Transcription</button>
            <button id="stopBtn" class="btn btn--danger-ghost" disabled>Stop Transcription</button>
        </div>

        <div id="status" class="dg-status dg-status--error">Disconnected</div>

        <!-- Side-by-side layout container -->
        <div style="display: flex; gap: 20px; margin-top: 20px;">
            <!-- Left container: Live Transcription -->
            <div style="flex: 1; min-width: 0;">
                <h3 style="margin-bottom: 10px; color: var(--dg-gray-700);">Live Transcription</h3>
                <div id="transcription" class="dg-code-block" style="max-height: 350px; overflow-y: auto;">
                    <pre><code>Click "Start Transcription" and speak into your microphone to see live transcription results here.</code></pre>
                </div>
            </div>

            <!-- Right container: Parsed Responses -->
            <div style="flex: 1; min-width: 0;">
                <h3 style="margin-bottom: 10px; color: var(--dg-gray-700);">Assistant Messages</h3>
                <div id="parsedResponses" class="dg-code-block" style="max-height: 350px; overflow-y: auto; background-color: var(--dg-blue-50); border: 1px solid var(--dg-blue-200);">
                    <pre><code>Assistant notifications and suggestions will appear here.</code></pre>
                </div>
            </div>
        </div>

        <!-- Medical History Panel -->
        <div style="margin-top: 30px;">
            <h3 style="margin-bottom: 20px; color: var(--dg-gray-700);">Patient Medical History</h3>
            
            <!-- Completeness Progress Section -->
            <div style="margin-bottom: 25px; padding: 15px; background-color: var(--dg-gray-50); border-radius: 8px; border: 1px solid var(--dg-gray-200);">
                <h4 style="margin-bottom: 15px; color: var(--dg-gray-700); font-size: 1.1em;">📊 Section Completeness</h4>
                <div id="completenessBars" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px;">
                    <!-- Progress bars will be populated by JavaScript -->
                </div>
            </div>

            <!-- Medical History Grid -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Left Column -->
                <div id="leftColumn" style="display: flex; flex-direction: column; gap: 15px;">
                    <!-- Sections 1-6 will be populated here -->
                </div>
                
                <!-- Right Column -->
                <div id="rightColumn" style="display: flex; flex-direction: column; gap: 15px;">
                    <!-- Sections 7-12 will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let isRecording = false;

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const transcription = document.getElementById('transcription');
        const parsedResponses = document.getElementById('parsedResponses');

        function updateStatus(message, isConnected = false) {
            status.textContent = message;
            status.className = `dg-status ${isConnected ? 'dg-status--success' : 'dg-status--error'}`;
        }

        function clearTranscription() {
            const transcriptionCodeElement = transcription.querySelector('code');
            const parsedCodeElement = parsedResponses.querySelector('code');
            transcriptionCodeElement.innerHTML = 'Ready to transcribe. Speak into your microphone...';
            parsedCodeElement.innerHTML = 'Parsed responses with detected keywords will appear here.';
        }

        function showError(message) {
            const codeElement = transcription.querySelector('code');
            const errorSpan = document.createElement('span');
            errorSpan.style.color = 'var(--dg-danger)';
            errorSpan.textContent = '❌ ' + message + '\n';
            codeElement.appendChild(errorSpan);
        }

        function addTranscriptionEntry(text, timestamp = null) {
            const codeElement = transcription.querySelector('code');
            const time = timestamp || new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.style.marginBottom = '8px';
            entry.style.padding = '4px 0';
            entry.style.borderBottom = '1px solid var(--dg-gray-200)';
            
            const timeSpan = document.createElement('span');
            timeSpan.style.color = 'var(--dg-gray-500)';
            timeSpan.style.fontSize = '0.8em';
            timeSpan.textContent = `[${time}] `;
            
            const typeSpan = document.createElement('span');
            typeSpan.style.fontSize = '0.7em';
            typeSpan.style.fontWeight = 'bold';
            typeSpan.style.marginRight = '4px';
            typeSpan.textContent = '🎤 ';
            typeSpan.style.color = 'var(--dg-gray-600)';
            
            const textSpan = document.createElement('span');
            textSpan.textContent = text;
            
            entry.appendChild(timeSpan);
            entry.appendChild(typeSpan);
            entry.appendChild(textSpan);
            codeElement.appendChild(entry);
            
            // Auto-scroll to bottom
            transcription.scrollTop = transcription.scrollHeight;
        }

        function addParsedResponseEntry(text, timestamp = null) {
            const codeElement = parsedResponses.querySelector('code');
            const time = timestamp || new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.style.marginBottom = '8px';
            entry.style.padding = '4px 0';
            entry.style.borderBottom = '1px solid var(--dg-blue-200)';
            
            const timeSpan = document.createElement('span');
            timeSpan.style.color = 'var(--dg-gray-500)';
            timeSpan.style.fontSize = '0.8em';
            timeSpan.textContent = `[${time}] `;
            
            const typeSpan = document.createElement('span');
            typeSpan.style.fontSize = '0.7em';
            typeSpan.style.fontWeight = 'bold';
            typeSpan.style.marginRight = '4px';
            typeSpan.textContent = '🔍 ';
            typeSpan.style.color = 'var(--dg-blue-600)';
            
            const textSpan = document.createElement('span');
            textSpan.textContent = text;
            
            entry.appendChild(timeSpan);
            entry.appendChild(typeSpan);
            entry.appendChild(textSpan);
            codeElement.appendChild(entry);
            
            // Auto-scroll to bottom
            parsedResponses.scrollTop = parsedResponses.scrollHeight;
        }

        let microphone = null;

        async function getMicrophone() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                return new MediaRecorder(stream, { mimeType: "audio/webm" });
            } catch (error) {
                console.error("Error accessing microphone:", error);
                throw error;
            }
        }

        async function openMicrophone(microphone, ws) {
            return new Promise((resolve) => {
                microphone.onstart = () => {
                    console.log("🎤 Microphone opened");
                    resolve();
                };

                microphone.ondataavailable = async (event) => {
                    console.log("📡 Audio data:", event.data.size, "bytes");
                    if (event.data.size > 0 && ws && ws.readyState === WebSocket.OPEN) {
                        console.log("📤 Sending audio chunk to backend");
                        ws.send(event.data);
                    }
                };

                microphone.start(250); // Send chunks every 250ms for better real-time performance
            });
        }

        async function startTranscription() {
            try {
                console.log('🎤 Starting transcription with MediaRecorder (WebM)...');

                microphone = await getMicrophone();
                console.log("✅ Microphone access granted");

                // Setup WebSocket
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${protocol}//${window.location.host}/ws/transcription/`);

                ws.onopen = () => {
                    updateStatus('Connected - Starting transcription...', true);
                    clearTranscription();

                    // Send toggle transcription message immediately to avoid timeout
                    ws.send(JSON.stringify({type: 'toggle_transcription'}));

                    startBtn.disabled = true;
                    stopBtn.disabled = false;

                    console.log("🟢 WebSocket connected, starting microphone...");
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    console.log('Received:', data.type);

                    if (data.type === 'transcription_update') {
                        addTranscriptionEntry(data.transcription, null);
                    } else if (data.type === 'parsed_response') {
                        addParsedResponseEntry(data.transcription, null);
                    } else if (data.type === 'section_update') {
                        updateMedicalHistorySection(data.section_name, data.new_data, data.completeness, data.original_new_data, data.is_increment);
                    } else if (data.type === 'transcription_status') {
                        updateStatus(`Connected - ${data.status}`, true);
                    } else if (data.type === 'error') {
                        showError(data.message);
                    }
                };

                ws.onclose = () => {
                    updateStatus('Disconnected');
                    stopRecording();
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Connection error');
                    showError('WebSocket connection failed');
                };

                // Start microphone recording
                console.log("🎙️ Waiting to open microphone");
                await openMicrophone(microphone, ws);
                isRecording = true;

            } catch (error) {
                console.error('Error starting transcription:', error);
                showError('Failed to access microphone: ' + error.message);
                updateStatus('Microphone access denied');
            }
        }

        function stopRecording() {
            if (isRecording && microphone) {
                console.log("🔇 Stopping microphone...");
                microphone.stop();
                microphone.stream.getTracks().forEach(track => track.stop());
                microphone = null;
                isRecording = false;
            }

            startBtn.disabled = false;
            stopBtn.disabled = true;
        }

        function stopTranscription() {
            if (ws) {
                ws.send(JSON.stringify({type: 'toggle_transcription'}));
                ws.close();
                ws = null;
            }
            stopRecording();
            updateStatus('Stopped');
        }

        startBtn.addEventListener('click', startTranscription);
        stopBtn.addEventListener('click', stopTranscription);

        // Medical History Data - Load from JSON file
        let patientHistory = null;

        // Function to load patient history data
        async function loadPatientHistory() {
            try {
                const response = await fetch('/static/patient_history.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                patientHistory = await response.json();
                console.log('✅ Patient history loaded successfully');
                initializeMedicalHistory();
            } catch (error) {
                console.error('❌ Error loading patient history:', error);
                // Show error in the medical history section
                const medicalHistorySection = document.querySelector('div[style*="margin-top: 30px"]');
                if (medicalHistorySection) {
                    medicalHistorySection.innerHTML = `
                        <div style="padding: 20px; background-color: var(--dg-danger-50); border: 1px solid var(--dg-danger-200); border-radius: 8px; color: var(--dg-danger-700);">
                            <h3 style="margin-bottom: 10px;">⚠️ Error Loading Patient History</h3>
                            <p>Failed to load patient history data: ${error.message}</p>
                            <p>Please ensure patient_history.json is available in the root directory.</p>
                        </div>
                    `;
                }
            }
        }

        // Function to get color based on completeness value
        function getCompletenessColor(value) {
            if (value >= 0.8) return '#008000'; // Green
            if (value >= 0.4) return '#FFA500'; // Yellow/Orange
            return '#FF0000'; // Red
        }

        // Function to create progress bar
        function createProgressBar(sectionName, value) {
            const container = document.createElement('div');
            container.style.cssText = `
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 8px;
                background: white;
                border-radius: 6px;
                border: 1px solid var(--dg-gray-200);
            `;

            const label = document.createElement('span');
            label.textContent = sectionName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            label.style.cssText = `
                font-size: 0.9em;
                font-weight: 500;
                color: #1a1a1a;
                min-width: 140px;
            `;

            const progressContainer = document.createElement('div');
            progressContainer.style.cssText = `
                flex: 1;
                height: 8px;
                background-color: #f0f0f0;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                overflow: hidden;
                position: relative;
            `;

            const progressBar = document.createElement('div');
            progressBar.style.cssText = `
                height: 100%;
                width: ${value * 100}%;
                background-color: ${getCompletenessColor(value)};
                transition: width 0.3s ease;
            `;

            const percentage = document.createElement('span');
            percentage.textContent = `${Math.round(value * 100)}%`;
            percentage.style.cssText = `
                font-size: 0.8em;
                font-weight: 600;
                color: var(--dg-gray-600);
                min-width: 35px;
                text-align: right;
            `;

            progressContainer.appendChild(progressBar);
            container.appendChild(label);
            container.appendChild(progressContainer);
            container.appendChild(percentage);

            return container;
        }

        // Function to format section data for display
        function formatSectionData(data) {
            if (Array.isArray(data)) {
                if (data.length === 0) return 'None reported';
                return data.map(item => {
                    if (typeof item === 'object' && item !== null) {
                        return formatSectionData(item);
                    }
                    return String(item);
                }).join(', ');
            }
            if (typeof data === 'object' && data !== null) {
                const formatted = [];
                for (const [key, value] of Object.entries(data)) {
                    if (value !== null && value !== undefined && value !== '') {
                        const keyName = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        if (typeof value === 'object' && !Array.isArray(value)) {
                            const nestedData = formatSectionData(value);
                            if (nestedData && nestedData !== 'None reported') {
                                formatted.push(`${keyName}: ${nestedData}`);
                            }
                        } else if (Array.isArray(value)) {
                            const arrayData = formatSectionData(value);
                            if (arrayData && arrayData !== 'None reported') {
                                formatted.push(`${keyName}: ${arrayData}`);
                            }
                        } else {
                            formatted.push(`${keyName}: ${String(value)}`);
                        }
                    }
                }
                return formatted.join('\n');
            }
            return String(data);
        }

        // Function to create section card
        function createSectionCard(title, data, completeness) {
            const card = document.createElement('div');
            card.setAttribute('data-section-name', title);
            card.style.cssText = `
                padding: 15px;
                background: white;
                border: 1px solid var(--dg-gray-200);
                border-radius: 8px;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
                padding-bottom: 8px;
                border-bottom: 1px solid var(--dg-gray-200);
                cursor: pointer;
                user-select: none;
            `;

            const titleContainer = document.createElement('div');
            titleContainer.style.cssText = `
                display: flex;
                align-items: center;
                gap: 8px;
            `;

            const expandIcon = document.createElement('span');
            expandIcon.textContent = '▶';
            expandIcon.style.cssText = `
                font-size: 0.8em;
                color: #666;
                transition: transform 0.2s ease;
            `;

            const titleElement = document.createElement('h4');
            titleElement.textContent = title.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            titleElement.style.cssText = `
                margin: 0;
                color: #1a1a1a;
                font-size: 1em;
                font-weight: 600;
            `;

            const completenessBadge = document.createElement('span');
            completenessBadge.className = 'completeness-badge';
            completenessBadge.textContent = `${Math.round(completeness * 100)}%`;
            completenessBadge.style.cssText = `
                background-color: ${getCompletenessColor(completeness)};
                color: white;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 0.75em;
                font-weight: 600;
            `;

            const content = document.createElement('div');
            content.className = 'section-content';
            content.style.cssText = `
                color: #1a1a1a;
                font-size: 0.9em;
                line-height: 1.4;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
            `;

            const formattedData = formatSectionData(data);
            console.log(`Section ${title}:`, data, 'Formatted:', formattedData);
            
            if (formattedData && formattedData !== 'None reported') {
                const lines = formattedData.split('\n');
                lines.forEach(line => {
                    if (line.trim()) {
                        const lineElement = document.createElement('div');
                        lineElement.style.cssText = `
                            margin-bottom: 4px;
                            padding: 2px 0;
                        `;
                        lineElement.textContent = line;
                        content.appendChild(lineElement);
                    }
                });
            } else {
                content.textContent = 'No data available';
            }

            // Collapse/expand functionality
            let isExpanded = false;
            
            function toggleContent() {
                isExpanded = !isExpanded;
                if (isExpanded) {
                    content.style.maxHeight = '300px';
                    expandIcon.style.transform = 'rotate(90deg)';
                    expandIcon.textContent = '▼';
                } else {
                    content.style.maxHeight = '0';
                    expandIcon.style.transform = 'rotate(0deg)';
                    expandIcon.textContent = '▶';
                }
            }

            header.addEventListener('click', toggleContent);

            titleContainer.appendChild(expandIcon);
            titleContainer.appendChild(titleElement);
            header.appendChild(titleContainer);
            header.appendChild(completenessBadge);
            card.appendChild(header);
            card.appendChild(content);

            return card;
        }

        // Function to initialize medical history
        function initializeMedicalHistory() {
            if (!patientHistory) {
                console.error('Patient history data not loaded');
                return;
            }

            const completenessBars = document.getElementById('completenessBars');
            const leftColumn = document.getElementById('leftColumn');
            const rightColumn = document.getElementById('rightColumn');

            // Clear existing content
            completenessBars.innerHTML = '';
            leftColumn.innerHTML = '';
            rightColumn.innerHTML = '';

            // Create progress bars
            const sectionOrder = [
                'core_demographics', 'illness_timeline', 'past_medical_history', 'family_history',
                'infection_exposure_history', 'gi_nutrition', 'dysautonomia_pots', 'mcas_allergic',
                'energy_pem_me_cfs', 'immune_inflammatory', 'medications_supplements', 'lifestyle_function'
            ];

            sectionOrder.forEach(sectionName => {
                const completeness = patientHistory.completeness[sectionName];
                const progressBar = createProgressBar(sectionName, completeness);
                completenessBars.appendChild(progressBar);
            });

            // Create section cards
            const leftSections = sectionOrder.slice(0, 6);
            const rightSections = sectionOrder.slice(6);

            leftSections.forEach(sectionName => {
                const completeness = patientHistory.completeness[sectionName];
                const data = patientHistory[sectionName];
                const card = createSectionCard(sectionName, data, completeness);
                leftColumn.appendChild(card);
            });

            rightSections.forEach(sectionName => {
                const completeness = patientHistory.completeness[sectionName];
                const data = patientHistory[sectionName];
                const card = createSectionCard(sectionName, data, completeness);
                rightColumn.appendChild(card);
            });
        }

        // Function to update medical history section
        function updateMedicalHistorySection(sectionName, newData, completeness, originalNewData, isIncrement = false) {
            console.log(`🏥 Updating section: ${sectionName}`, newData, completeness);
            
            // Find the existing section card
            const sectionCards = document.querySelectorAll('[data-section-name]');
            const targetCard = Array.from(sectionCards).find(card => 
                card.getAttribute('data-section-name') === sectionName
            );
            
            if (targetCard) {
                // Highlight the section card for 3 seconds
                targetCard.style.animation = 'highlightSection 3s ease';
                setTimeout(() => {
                    targetCard.style.animation = '';
                }, 3000);
                
                // Update the content
                const content = targetCard.querySelector('.section-content');
                const formattedData = formatSectionData(newData);
                
                // Clear existing content
                content.innerHTML = '';
                
                if (formattedData && formattedData !== 'None reported') {
                    const lines = formattedData.split('\n');
                    lines.forEach(line => {
                        if (line.trim()) {
                            const lineElement = document.createElement('div');
                            lineElement.style.cssText = `
                                margin-bottom: 4px;
                                padding: 2px 0;
                                animation: highlightNewText 3s ease;
                            `;
                            lineElement.textContent = line;
                            content.appendChild(lineElement);
                        }
                    });
                } else {
                    content.textContent = 'No data available';
                }
                
                // Calculate new completeness by adding increment to existing value
                const currentCompleteness = patientHistory.completeness[sectionName] || 0;
                const newCompleteness = isIncrement ? 
                    Math.min(1.0, currentCompleteness + completeness) : // Add increment, cap at 100%
                    Math.min(1.0, completeness); // Use absolute value, cap at 100%
                
                // Update completeness badge with animation
                const badge = targetCard.querySelector('.completeness-badge');
                if (badge) {
                    badge.style.animation = 'pulseBadge 1s ease';
                    setTimeout(() => {
                        badge.textContent = `${Math.round(newCompleteness * 100)}%`;
                        badge.style.backgroundColor = getCompletenessColor(newCompleteness);
                        badge.style.animation = '';
                    }, 500);
                }
                
                // Update progress bar
                updateCompletenessBar(sectionName, newCompleteness);
                
                // Update the in-memory patient history
                patientHistory.completeness[sectionName] = newCompleteness;
                
                // Add success notification
                showUpdateNotification(sectionName, originalNewData, completeness, isIncrement);
                
                console.log(`✅ Section ${sectionName} updated successfully - Completeness: ${currentCompleteness} + ${completeness} = ${newCompleteness}`);
            } else {
                console.warn(`⚠️ Section card not found for: ${sectionName}`);
            }
        }

        // Function to show update notification in parsed responses
        function showUpdateNotification(sectionName, newData, completeness, isIncrement = false) {
            const codeElement = parsedResponses.querySelector('code');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.style.marginBottom = '8px';
            entry.style.padding = '4px 0';
            entry.style.borderBottom = '1px solid var(--dg-blue-200)';
            entry.style.animation = 'fadeIn 0.3s ease';
            
            const timeSpan = document.createElement('span');
            timeSpan.style.color = 'var(--dg-gray-500)';
            timeSpan.style.fontSize = '0.8em';
            timeSpan.textContent = `[${time}] `;
            
            const typeSpan = document.createElement('span');
            typeSpan.style.fontSize = '0.7em';
            typeSpan.style.fontWeight = 'bold';
            typeSpan.style.marginRight = '4px';
            typeSpan.textContent = '🏥 ';
            typeSpan.style.color = 'var(--dg-green-600)';
            
            const sectionDisplayName = sectionName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            // Create the main text
            const textSpan = document.createElement('span');
            textSpan.style.color = 'var(--dg-green-700)';
            textSpan.style.fontWeight = '500';
            
            // Show increment information if applicable
            if (isIncrement) {
                textSpan.textContent = `${sectionDisplayName} Updated (+${Math.round(completeness * 100)}%): `;
            } else {
                textSpan.textContent = `${sectionDisplayName} Updated: `;
            }
            
            // Add details about what was added
            const detailsSpan = document.createElement('span');
            detailsSpan.style.color = 'var(--dg-gray-700)';
            detailsSpan.style.fontWeight = 'normal';
            
            const updateDetails = [];
            for (const [key, value] of Object.entries(newData)) {
                if (Array.isArray(value)) {
                    // For arrays, show what was added
                    updateDetails.push(`Added ${key.replace(/_/g, ' ')}: ${value.join(', ')}`);
                } else if (typeof value === 'object' && value !== null) {
                    // Handle nested objects like lab results
                    for (const [nestedKey, nestedValue] of Object.entries(value)) {
                        updateDetails.push(`Updated ${nestedKey}: ${nestedValue}`);
                    }
                } else {
                    updateDetails.push(`Updated ${key.replace(/_/g, ' ')}: ${value}`);
                }
            }
            
            detailsSpan.textContent = updateDetails.join('; ');
            
            entry.appendChild(timeSpan);
            entry.appendChild(typeSpan);
            entry.appendChild(textSpan);
            entry.appendChild(detailsSpan);
            codeElement.appendChild(entry);
            
            // Auto-scroll to bottom
            parsedResponses.scrollTop = parsedResponses.scrollHeight;
            
            // Add a brief highlight effect to the entry
            setTimeout(() => {
                entry.style.background = 'rgba(76, 175, 80, 0.1)';
                entry.style.borderRadius = '4px';
                entry.style.padding = '6px 8px';
                setTimeout(() => {
                    entry.style.background = '';
                    entry.style.borderRadius = '';
                    entry.style.padding = '4px 0';
                }, 2000);
            }, 100);
        }

        // Function to update completeness progress bar
        function updateCompletenessBar(sectionName, completeness) {
            const progressBars = document.querySelectorAll('#completenessBars > div');
            const targetBar = Array.from(progressBars).find(bar => {
                const label = bar.querySelector('span');
                return label && label.textContent.toLowerCase().includes(sectionName.replace(/_/g, ' '));
            });
            
            if (targetBar) {
                const progressBar = targetBar.querySelector('div > div');
                const percentage = targetBar.querySelector('span:last-child');
                
                if (progressBar) {
                    // Animate the progress bar update
                    progressBar.style.transition = 'width 0.8s ease, background-color 0.8s ease';
                    progressBar.style.width = `${completeness * 100}%`;
                    progressBar.style.backgroundColor = getCompletenessColor(completeness);
                    
                    // Add a brief highlight effect
                    targetBar.style.animation = 'highlightProgressBar 1s ease';
                    setTimeout(() => {
                        targetBar.style.animation = '';
                        progressBar.style.transition = '';
                    }, 1000);
                }
                
                if (percentage) {
                    // Animate the percentage text
                    percentage.style.animation = 'pulseText 0.5s ease';
                    setTimeout(() => {
                        percentage.textContent = `${Math.round(completeness * 100)}%`;
                        percentage.style.animation = '';
                    }, 250);
                }
            }
        }

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-5px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            @keyframes highlightSection {
                0% { 
                    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                    transform: scale(1);
                }
                10% { 
                    box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.4);
                    transform: scale(1.02);
                }
                90% { 
                    box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.2);
                    transform: scale(1.02);
                }
                100% { 
                    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                    transform: scale(1);
                }
            }
            
            @keyframes highlightNewText {
                0% { 
                    background-color: rgba(76, 175, 80, 0.3);
                    color: #2E7D32;
                    font-weight: bold;
                    padding: 4px 8px;
                    border-radius: 4px;
                }
                80% { 
                    background-color: rgba(76, 175, 80, 0.1);
                    color: #2E7D32;
                    font-weight: bold;
                    padding: 4px 8px;
                    border-radius: 4px;
                }
                100% { 
                    background-color: transparent;
                    color: #1a1a1a;
                    font-weight: normal;
                    padding: 2px 0;
                    border-radius: 0;
                }
            }
            
            @keyframes pulseBadge {
                0% { transform: scale(1); }
                50% { transform: scale(1.2); }
                100% { transform: scale(1); }
            }
            

            
            @keyframes highlightProgressBar {
                0% { 
                    background-color: rgba(76, 175, 80, 0.1);
                    border-radius: 6px;
                }
                50% { 
                    background-color: rgba(76, 175, 80, 0.2);
                    border-radius: 6px;
                }
                100% { 
                    background-color: white;
                    border-radius: 6px;
                }
            }
            
            @keyframes pulseText {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); color: #2E7D32; }
                100% { transform: scale(1); }
            }
        `;
        document.head.appendChild(style);

        // Initialize medical history when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadPatientHistory();
        });

        // Initialize
        updateStatus('Ready to start');
    </script>
</body>
</html>
